

https://www.davidzeleny.net/anadat-r/doku.php/en:start


https://www.sciencedirect.com/science/article/pii/0016706170900352


Demonstration of hierarchy as split by an increasing number of clusters (via `cutree`) using the  [`clustree`](https://lazappi.github.io/clustree/articles/clustree.html) package. I'm still trying to figure this one out.
```{r fig.height=10, fig.width=10}
library(clustree)

# original labels and clustering vectors generated by "cutting" the divising hierarchical clustering
x <- data.frame(
  series=profile_id(s$SPC),
  K1 = cutree(res$clust, 1),
  K2 = cutree(res$clust, 2),
  K3 = cutree(res$clust, 3),
  K4 = cutree(res$clust, 4),
  K5 = cutree(res$clust, 5),
  K6 = cutree(res$clust, 6),
  K7 = cutree(res$clust, 7),
  K8 = cutree(res$clust, 8),
  K9 = cutree(res$clust, 9),
  K10 = cutree(res$clust, 10),
  K11 = cutree(res$clust, 11),
  stringsAsFactors = FALSE
)

# convenience function for labelling nodes
# based on code found at: https://lazappi.github.io/clustree/articles/clustree.html
label_series <- function(labels) {
  n <- length(unique(labels))
  
  if (n <= 4 & n > 1) {
    lab <- paste(unique(labels), collapse=',')
    return(lab)
  } 
  if (n == 1) {
    lab <- as.character(unique(labels))
    return(lab)
  } else {
    lab <- 'mixed'
    return(lab)
  }
  
}

# now how to interpret...?
clustree(x, prefix = "K", node_label = "series",
         node_label_aggr = "label_series") + guides(edge_colour = FALSE, edge_alpha = FALSE, size=FALSE)
```


### Color Distance Metrics
https://github.com/thomasp85/farver





### tSNE and other dimension reduction / ordination methods


### Interpretation and Goodness of Fit
**TODO: add some explanation here **

[Shephard diagram](http://cc.oulu.fi/~jarioksa/softhelp/vegan/html/goodness.metaMDS.html)
```{r, eval=FALSE}
# MASS library
d.shep <- Shepard(d, d.sammon$points)
plot(d.shep, pch='.')
lines(d.shep$x, d.shep$yf, type = 'S', col='blue', lwd=2)

## vegan library
# compute distance between ES
d <- metaMDSdist(m[, -1])

# try ordination: non-metrix multidimensional scaling with default distance metric and standardization
# use all columns except first: the ES ID
nmds <- metaMDS(m[, -1])

# evaluate nmMDS fit
stressplot(nmds)

# GOF by site, smaller = better
hist(goodness(nmds))

```


## Species Composition

**TODO: finish this**
  
  The following is an example of the use of ordination to investigate patterns in species composition. It is from MLRA 22A-Sierra Nevada Mountains, CA. Data courtesy of David Evans (Sonora, CA).

<div style="font-size:95%; font-style: italic; width: 90%; margin: auto;"><p>These analyses were based on data summaries from AKSite.  Previous work in the vegan package, I had supplied the entire dataset for MLRA 18.  This included every single observation, including trace species occurring on plots that were outside central concepts and questionable community phases.</p>
  <p>To simplify this set, I selected aggregated data plant cover (% ocular estimates of canopy cover) from only the representative data community (reference phase) and included only the species that were contained in more than one plot.  Therefore, many of the trace species and rare plants will have been precluded.</p>
  <p>In essence, this dataset is aggregated and based on ecological sites.  My previous set was from point data and I was able to fit a number of environmental factors to the NMDS plots.  However, because these were aggregated data, they were not spatially explicit.  I did fit some production data, however I need to note some disclaimers on the validity of the production data.  Production data should only be collected during a narrow timeframe over the course of the year (i.e. during a specific phenology of the plant in question) usually in the spring.  Therefore, the production data is a bit limited and I had to scrape a couple of different sources together.  There were a couple of ecological sites in this analysis that had no production data. I did my best to find low, RV, and high values based out of the data we had collected.  However, in certain circumstances, I had an RV and a low, but no high, or vice versa.  In these cases, I made a judgement call based on my experience in these systems.</p></div>
  
  
  
```{r}
library(reshape2)
library(vegan)
library(cluster)

# read-in species data, with slightly modified column names
x <- read.csv('https://raw.githubusercontent.com/ncss-tech/stats_for_soil_survey/master/data/clustering_and_ordination/Blue.csv', stringsAsFactors = FALSE)

# read-in environmental data
prd <- read.csv('https://raw.githubusercontent.com/ncss-tech/stats_for_soil_survey/master/data/clustering_and_ordination/Blue_env.csv', stringsAsFactors = FALSE)

# check: looks good, except for the leading whitespace in the species codes
str(x)
head(x)

# strip out whitespace
x$species <- gsub(pattern=' ', replacement='', x=x$species)

# compute mean pct cover
x$pct_mean <- with(x, (pct_low + pct_high) / 2)

# convert "long" format to full community matrix, "wide" format using the mean pct cover
# 1 row / ES ID, each column is a species
p <- dcast(x, es_id ~ species, value.var = 'pct_mean')

# check: looks good, except missing data (NA) should be 0
str(p)
head(p, 1)

# replace NA in the community matrix with 0
p[is.na(p)] <- 0

# check range in mean pct cover, using all but the first column (the ES ID)
# looks good
summary(unlist(p[, -1]))

# re-order environmental data so that row order == community matrix
new.order <- match(p$es_id, prd$es_id)
# check
all(prd$es_id[new.order] == p$es_id)
# re-order
prd <- prd[new.order, ]




## now do something with the community matrix

# functions in the vegan package use the row names as IDs

# transfer the full ES ID to row names
row.names(p) <- p$es_id

## optional fun stuff

# how much of the ES ID can we trim-off?
# convert to a matrx and check by column
e.ids <- do.call('rbind', strsplit(p$es_id, split = ''))
column.unique.vals <- apply(e.ids, 2, function(i) length(unique(i)))
unique.cols <- which(column.unique.vals > 1)

# transfer the truncated IDs to row names
row.names(p) <- apply(e.ids[, unique.cols], 1, paste, collapse='')

# compute distance between ES
d <- metaMDSdist(p[, -1])

# try ordination: non-metrix multidimensional scaling with default distance metric and standardization
# use all columns except first: the ES ID
nmds <- metaMDS(p[, -1])


# plot
par(mar=c(2,2,1,1))
# blue = species
fig <- ordiplot(nmds, type='none', cex.axis=0.75)
abline(h=0, v=0, lty=2, col='grey')
text(fig, "species", col="blue", cex=0.5)

# re-use the ordination object 'fig'

# black= truncated ES IDs
ordiplot(fig, type='none', cex.axis=0.75)
abline(h=0, v=0, lty=2, col='grey')
text(fig, "sites", col="black", cex=0.85)

# another view: blue = species, black= truncated ES IDs
# clusters connected with orange lines
ordiplot(fig, type='none', cex.axis=0.75)
abline(h=0, v=0, lty=2, col='grey')
ordicluster(fig, agnes(d, method='ward'), prune=3, col = "orange")
text(fig, "sites", col="black", cex=0.75, font=2)
text(fig, "species", col="blue", cex=0.5)


## community matrix as heatmap
tabasco(p[, -1])
# standardized community matrix
tabasco(wisconsin(p[, -1]))
# add site clustering of distance matrix
tabasco(wisconsin(p[, -1]), use=agnes(d, method='ward'))
# sort rows / columns based on NMMDS results
tabasco(wisconsin(p[, -1]), use=nmds)


## add environmental data

# production
fig <- ordiplot(nmds, type='none', cex.axis=0.75)
abline(h=0, v=0, lty=2, col='grey')
text(fig, "species", col="blue", cex=0.5)
ordilabel(fig, "sites", col="black", cex=0.75, font=2)
fit <- ordisurf(fig, prd$prod_normal, add=TRUE)



# nmds.production <- MDSrotate(nmds, prd$prod_normal)
# fig <- ordiplot(nmds.production, type='none', cex.axis=0.75)
# abline(h=0, v=0, lty=2, col='grey')
# text(fig, "sites", col="black", cex=0.75, font=2)
# text(fig, "species", col="blue", cex=0.5)
# fit <- ordisurf(fig, prd$prod_normal, add=TRUE)


### things to tinker with:

specaccum(p[, -1])
diversity(p[, -1])

## disconnected distances via threshold...?
distconnected(d)

# indicator power ... ?
ip <- indpower(p[, -1])
diag(ip) <- NA
ip[, 1]
which.max(ip[, 1])




## spanning tree
tr <- spantree(d)
## Add tree to a metric scaling 
plot(tr, nmds, type = "t")
```

```{r, eval=FALSE, fig.width=5, fig.height=5}
# evaluate nmMDS fit
par(mar=c(5,5,1,1))
stressplot(nmds, cex=0.5)
```

```{r, eval=FALSE, fig.width=10, fig.height=5}
# plot
par(mar=c(1,1,1,1), mfcol=c(1,2))

# "species"
fig <- ordiplot(nmds, type='none', axes=FALSE)
abline(h=0, v=0, lty=2, col='grey')
text(fig, "species", col="blue", cex=0.5)
title('Species', line=-0.5)

# "sites"
# re-use the ordination object 'fig'
ordiplot(fig, type='none', axes=FALSE)
abline(h=0, v=0, lty=2, col='grey')
text(fig, "sites", col="black", cex=0.5)
title('Sites', line=-0.5)
```


### Topographic Signatures

The following is an investigation of topographic "signatures" from the initial soil mapping project of Sequoia and Kings Canyon National Park, CA.

```{r, fig.width=8, fig.height=8, results='hide'}
library(plyr)
library(reshape2)
library(vegan)
library(cluster)

# init a temp file
tf <- tempfile()

# download compressed CSV to temp file
download.file('https://github.com/ncss-tech/stats_for_soil_survey/raw/master/data/clustering_and_ordination/seki-mu-gis-samples.csv.gz', destfile = tf, quiet = TRUE)
# read-in from compressed CSV to data.frame object
x <- read.csv(gzfile(tf), stringsAsFactors = FALSE)

# check
head(x)

# get terrain variable names
vars <- c('elev', 'solar', 'slope', 'tci', 'ppt', 'maat', 'tpi', 'tri', 'pi')

# covnvert wide to long format for summary by MY symbol
x.long <- melt(x, id.vars = 'MUSYM', measure.vars = vars)
x.summary <- ddply(x.long, c('MUSYM', 'variable'), .fun=plyr::summarize, m=median(value, na.rm = TRUE))
head(x.summary)

# retain median values, convert back to wide format
x.wide <- dcast(x.summary, MUSYM ~ variable, value.var = 'm')
row.names(x.wide) <- x.wide$MUSYM
head(x.wide, 2)

# generate lookup table of MUSYM - MU groups
lut <- unique(x[, c('MUSYM', 'gensym')])

# join data matrix with lut
x.wide <- join(x.wide, lut, by='MUSYM', type='left', match='first')
x.wide$gensym <- factor(x.wide$gensym, levels = c("riparian", "xx10", "xx20", "xx30", "xx40", "xx50"), labels = c("riparian", "basins and cirques", "glacial valleys", "bedrock controlled mountain slopes and valley walls", "non bedrock controlled slopes", "plateaus, till plains, outwash plains"))

# perform non-metric MDS
nmds <- metaMDS(x.wide[, vars], distance = 'gower', autotransform = FALSE, wascores=FALSE)

# setup colors
cols <- c('RoyalBlue', 'black', 'DarkGreen', 'orange3', 'red', 'brown')
site.colors <- cols[as.numeric(x.wide$gensym)]

# plot ordination
par(mar=c(1,1,1,1))
fig <- ordiplot(nmds, type='none', cex.axis=0.75, axes=FALSE)
abline(h=0, v=0, lty=2, col='grey')
text(fig, "sites", cex=0.65, font=2, col=site.colors)
legend('bottomleft', legend=levels(x.wide$gensym), col=cols, pch=15, pt.cex=2, bty='n', cex=1)
title('Map Unit Terrain Signatures')
```

