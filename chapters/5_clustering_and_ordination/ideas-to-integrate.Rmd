
## Species Composition

**TODO: finish this**
  
  The following is an example of the use of ordination to investigate patterns in species composition. It is from MLRA 22A-Sierra Nevada Mountains, CA. Data courtesy of David Evans (Sonora, CA).

<div style="font-size:95%; font-style: italic; width: 90%; margin: auto;"><p>These analyses were based on data summaries from AKSite.  Previous work in the vegan package, I had supplied the entire dataset for MLRA 18.  This included every single observation, including trace species occurring on plots that were outside central concepts and questionable community phases.</p>
  <p>To simplify this set, I selected aggregated data plant cover (% ocular estimates of canopy cover) from only the representative data community (reference phase) and included only the species that were contained in more than one plot.  Therefore, many of the trace species and rare plants will have been precluded.</p>
  <p>In essence, this dataset is aggregated and based on ecological sites.  My previous set was from point data and I was able to fit a number of environmental factors to the NMDS plots.  However, because these were aggregated data, they were not spatially explicit.  I did fit some production data, however I need to note some disclaimers on the validity of the production data.  Production data should only be collected during a narrow timeframe over the course of the year (i.e. during a specific phenology of the plant in question) usually in the spring.  Therefore, the production data is a bit limited and I had to scrape a couple of different sources together.  There were a couple of ecological sites in this analysis that had no production data. I did my best to find low, RV, and high values based out of the data we had collected.  However, in certain circumstances, I had an RV and a low, but no high, or vice versa.  In these cases, I made a judgement call based on my experience in these systems.</p></div>
  
  
  
  ```{r}
library(reshape2)
library(vegan)
library(cluster)

# read-in species data, with slightly modified column names
x <- read.csv('https://raw.githubusercontent.com/ncss-tech/stats_for_soil_survey/master/data/clustering_and_ordination/Blue.csv', stringsAsFactors = FALSE)

# read-in environmental data
prd <- read.csv('https://raw.githubusercontent.com/ncss-tech/stats_for_soil_survey/master/data/clustering_and_ordination/Blue_env.csv', stringsAsFactors = FALSE)

# check: looks good, except for the leading whitespace in the species codes
str(x)
head(x)

# strip out whitespace
x$species <- gsub(pattern=' ', replacement='', x=x$species)

# compute mean pct cover
x$pct_mean <- with(x, (pct_low + pct_high) / 2)

# convert "long" format to full community matrix, "wide" format using the mean pct cover
# 1 row / ES ID, each column is a species
p <- dcast(x, es_id ~ species, value.var = 'pct_mean')

# check: looks good, except missing data (NA) should be 0
str(p)
head(p, 1)

# replace NA in the community matrix with 0
p[is.na(p)] <- 0

# check range in mean pct cover, using all but the first column (the ES ID)
# looks good
summary(unlist(p[, -1]))

# re-order environmental data so that row order == community matrix
new.order <- match(p$es_id, prd$es_id)
# check
all(prd$es_id[new.order] == p$es_id)
# re-order
prd <- prd[new.order, ]




## now do something with the community matrix

# functions in the vegan package use the row names as IDs

# transfer the full ES ID to row names
row.names(p) <- p$es_id

## optional fun stuff

# how much of the ES ID can we trim-off?
# convert to a matrx and check by column
e.ids <- do.call('rbind', strsplit(p$es_id, split = ''))
column.unique.vals <- apply(e.ids, 2, function(i) length(unique(i)))
unique.cols <- which(column.unique.vals > 1)

# transfer the truncated IDs to row names
row.names(p) <- apply(e.ids[, unique.cols], 1, paste, collapse='')

# compute distance between ES
d <- metaMDSdist(p[, -1])

# try ordination: non-metrix multidimensional scaling with default distance metric and standardization
# use all columns except first: the ES ID
nmds <- metaMDS(p[, -1])


# plot
par(mar=c(2,2,1,1))
# blue = species
fig <- ordiplot(nmds, type='none', cex.axis=0.75)
abline(h=0, v=0, lty=2, col='grey')
text(fig, "species", col="blue", cex=0.5)

# re-use the ordination object 'fig'

# black= truncated ES IDs
ordiplot(fig, type='none', cex.axis=0.75)
abline(h=0, v=0, lty=2, col='grey')
text(fig, "sites", col="black", cex=0.85)

# another view: blue = species, black= truncated ES IDs
# clusters connected with orange lines
ordiplot(fig, type='none', cex.axis=0.75)
abline(h=0, v=0, lty=2, col='grey')
ordicluster(fig, agnes(d, method='ward'), prune=3, col = "orange")
text(fig, "sites", col="black", cex=0.75, font=2)
text(fig, "species", col="blue", cex=0.5)


## community matrix as heatmap
tabasco(p[, -1])
# standardized community matrix
tabasco(wisconsin(p[, -1]))
# add site clustering of distance matrix
tabasco(wisconsin(p[, -1]), use=agnes(d, method='ward'))
# sort rows / columns based on NMMDS results
tabasco(wisconsin(p[, -1]), use=nmds)


## add environmental data

# production
fig <- ordiplot(nmds, type='none', cex.axis=0.75)
abline(h=0, v=0, lty=2, col='grey')
text(fig, "species", col="blue", cex=0.5)
ordilabel(fig, "sites", col="black", cex=0.75, font=2)
fit <- ordisurf(fig, prd$prod_normal, add=TRUE)



# nmds.production <- MDSrotate(nmds, prd$prod_normal)
# fig <- ordiplot(nmds.production, type='none', cex.axis=0.75)
# abline(h=0, v=0, lty=2, col='grey')
# text(fig, "sites", col="black", cex=0.75, font=2)
# text(fig, "species", col="blue", cex=0.5)
# fit <- ordisurf(fig, prd$prod_normal, add=TRUE)


### things to tinker with:

specaccum(p[, -1])
diversity(p[, -1])

## disconnected distances via threshold...?
distconnected(d)

# indicator power ... ?
ip <- indpower(p[, -1])
diag(ip) <- NA
ip[, 1]
which.max(ip[, 1])




## spanning tree
tr <- spantree(d)
## Add tree to a metric scaling 
plot(tr, nmds, type = "t")
```

```{r, eval=FALSE, fig.width=5, fig.height=5}
# evaluate nmMDS fit
par(mar=c(5,5,1,1))
stressplot(nmds, cex=0.5)
```

```{r, eval=FALSE, fig.width=10, fig.height=5}
# plot
par(mar=c(1,1,1,1), mfcol=c(1,2))

# "species"
fig <- ordiplot(nmds, type='none', axes=FALSE)
abline(h=0, v=0, lty=2, col='grey')
text(fig, "species", col="blue", cex=0.5)
title('Species', line=-0.5)

# "sites"
# re-use the ordination object 'fig'
ordiplot(fig, type='none', axes=FALSE)
abline(h=0, v=0, lty=2, col='grey')
text(fig, "sites", col="black", cex=0.5)
title('Sites', line=-0.5)
```



<!-- * [problems assoc. with too many dimensions](https://en.wikipedia.org/wiki/Clustering_high-dimensional_data) -->



