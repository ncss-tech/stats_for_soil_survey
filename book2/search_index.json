[["index.html", "Statistics for Soil Survey - Part 2 Pre-course Assignment 0.1 Setup 0.2 Install .RProfile 0.3 Install Required Packages 0.4 Common Errors 0.5 Packages not on CRAN 0.6 Connect to Local NASIS 0.7 Proof 0.8 Additional Support/Optional Readings", " Statistics for Soil Survey - Part 2 Soil Survey Staff 2021-02-10 Pre-course Assignment 0.1 Setup 0.1.1 Create Workspace Make a local folder C:\\workspace2 to use as a working directory for this course. Use all lower case letters please. 0.1.2 Configure RStudio Open RStudio, and edit the Global Options (Main menu: Tools  Global Options). 0.1.3 Essentials These options are important for pleasant, reproducible and efficient use of the RStudio environment: Change the default working directory to C:\\workspace2 (R General Tab) Uncheck Restore .Rdata into workspace at startup (R General Tab) VERY IMPORTANT Figure 1: Example of RStudio General settings. RStudio detects the available R installations on your computer. Individual versions are certified for the Software Center as they become available, and sometimes there is a more recent version available for download. It is worth taking the time before installing packages to get the latest version of R available to you. This is to minimize compatibility issues which arise over time. 0.1.4 Personalization Figure 2: Example of RStudio Code/Editing settings. Optional: Check Soft-wrap R source files (Code/Editing Tab) Optional: Show help tooltips, control auto-completion and diagnostics (Code/Completion and Diagnostics Tabs) Optional: Update code font size, colors and theme (Appearance) Optional: Use RStudio Projects (top-right corner) to manage working directories 0.2 Install .RProfile The code you run next will establish a safe location for your R package library. Your package library should ideally be on a local disk with about 1 - 2 GB of free space. We want to prevent installs to ~ (your $HOME directory) which is typically on a network share (such as H:/), not a local disk. Copy the following code in the box below and paste into the R console panel after the command prompt (&gt;) and press enter. Hint: the R console is the lower left or left window in RStudio with a tab labeled Console. source(&#39;https://raw.githubusercontent.com/ncss-tech/soilReports/master/R/installRprofile.R&#39;) installRprofile(overwrite=TRUE) An updated set of library paths will be printed. Close and re-open RStudio, or Restart R (Main menu: Session  Restart R; or Ctrl+Shift+F10), before continuing to the next steps. Figure 3: Example of RStudio Console - the R library paths are on a local drive C:/ When your .Rprofile is set up correctly you will see output in a new R console/session confirming your library paths are: on a local drive (such as C:/) specific to the version number of R installed (such as 4.0) 0.3 Install Required Packages Packages can be installed by name from the Comprehensive R Archive Network (CRAN) using the base R function install.packages There are a lot of packages out there  many more than you will download here, and many of which are useful for Soil Survey work. The first time you install packages, R will ask you if you want to create a local repository in your User Documents folder. Click Yes. For example, to download and install the remotes package from CRAN: install.packages(&quot;remotes&quot;) To install the R packages used in this class copy all of the code from the box below and paste into the R console window. Paste after the command prompt (&gt;) and press enter. Downloading and configuring the packages will take a while if you are installing or upgrading all of the packages in the list below. # ipkCRAN: a helper function for installing required packages from CRAN # - p: vector of package names # - up: logical - upgrade installed packages? Default: TRUE ipkCRAN &lt;- function(p, up = TRUE){ message(&#39;installing packages from CRAN...&#39;) if (up) { # default is to re-install everything install.packages(p, dependencies = TRUE) } else { # but if up != TRUE install just what is needed new.pkg &lt;- p[! (p %in% installed.packages()[, &quot;Package&quot;])] if (length(new.pkg) &gt; 0) { install.packages(new.pkg, dependencies = TRUE) } } # finally, check and see if any failed missing.pkg &lt;- p[! (p %in% installed.packages()[, &quot;Package&quot;])] if (length(missing.pkg) &gt; 0) { warning(sprintf(&#39;\\033[31mOne or more packages failed to install!\\033[39m\\n%s&#39;, sprintf(&quot;Restart R then try `\\033[35minstall.packages(c(%s))\\033[39m`&quot;, paste0(sprintf(&#39;&quot;%s&quot;&#39;, missing.pkg), collapse = &quot;,&quot;))), call. = FALSE) } } ## character vector of packages packages &lt;- c( # soil &quot;aqp&quot;, &quot;soilDB&quot;, &quot;sharpshootR&quot;, &quot;soiltexture&quot;, # gis &quot;rgdal&quot;, &quot;raster&quot;, &quot;sp&quot;, &quot;sf&quot;, &quot;terra&quot;, &quot;gdalUtils&quot;, &quot;rgrass7&quot;, &quot;RSAGA&quot;, &quot;exactextractr&quot;, &quot;fasterize&quot;, # data management &quot;dplyr&quot;, &quot;tidyr&quot;, &quot;devtools&quot;, &quot;roxygen2&quot;, &quot;Hmisc&quot;, &quot;RODBC&quot;, &quot;circular&quot;, &quot;DT&quot;, &quot;remotes&quot;, # graphics &quot;ggplot2&quot;, &quot;latticeExtra&quot;, &quot;maps&quot;, &quot;spData&quot;, &quot;tmap&quot;, &quot;mapview&quot;, &quot;plotrix&quot;, &quot;rpart.plot&quot;, &quot;visreg&quot;, # modeling &quot;car&quot;, &quot;rms&quot;, &quot;randomForest&quot;, &quot;ranger&quot;, &quot;party&quot;, &quot;caret&quot;, &quot;vegan&quot;, &quot;ape&quot;, &quot;shape&quot;, # sampling &quot;clhs&quot; ) ## install vector of CRAN packages &quot;safely&quot; ## up = TRUE to download all packages ## up = FALSE to download only packages you don&#39;t already have installed ipkCRAN(packages, up = TRUE) The ipkCRAN function will let you know if any of the above packages fail to install. Any time you run code, always check the console output for warnings and errors before continuing. If a lot of output is produced by a command you should scroll up and sift through. It may be best early on to send commands individually to learn about and inspect their output. 0.4 Common Errors 0.4.1 No output is produced after pasting into console If you do not have a new command prompt (&gt;) and a blinking cursor on the left hand side of your console, but instead see a + after you run a command, R may think you are still in the middle of submitting input to the read-eval-print-loop (REPL). If this is not expected you are possibly missing closing quotes, braces, brackets or parentheses. R needs to know you were done with your expression, so you may need to supply some input to get the command to be complete. You can use the shortcut Ctrl+C to get out of a partially-complete command. Pasting code line-by-line is useful but prone to input errors with multi-line expressions. Alternately, you can run commands or an entire file using the GUI or keyboard shortcuts such as Ctrl+Enter. You have a chance to try this in the example at the end. 0.4.2 SOMEPACKAGE is not available (for R version X.Y.Z) This means either: A package named SOMEPACKAGE exists but it is not available for your version of R CRAN does not have a package with that name You can try again, but first check for spelling and case-sensitivity. When in doubt search the package name on Google or CRAN to make sure you have it right. Note that not all R packages are available on CRAN: there are many other ways that you can deliver packages (including GitHub described below). 0.5 Packages not on CRAN To install the latest version of packages from the Algorithms for Quantitative Pedology (AQP) suite off GitHub we use the remotes package. The AQP packages are updated much more frequently on GitHub than they are on CRAN. Generally, the CRAN versions (installed above) are the stable releases whereas the GitHub repositories have new features and bug fixes. remotes::install_github(&quot;ncss-tech/aqp&quot;, dependencies=FALSE, upgrade=FALSE, build=FALSE) remotes::install_github(&quot;ncss-tech/soilDB&quot;, dependencies=FALSE, upgrade=FALSE, build=FALSE) remotes::install_github(&quot;ncss-tech/soilReports&quot;, dependencies=FALSE, upgrade=FALSE, build=FALSE) remotes::install_github(&quot;ncss-tech/sharpshootR&quot;, dependencies=FALSE, upgrade=FALSE, build=FALSE) 0.6 Connect to Local NASIS Establish an ODBC connection to NASIS by following the directions at the following hyperlink (ODBC Connection to NASIS). Once youve successfully established a ODBC connection, prove it by loading your NASIS selected set with the site and pedon tables for any pedons from your local area. You only need a few pedons at a minimum for this demo  too many (say, &gt;20) will make the example profile plot cluttered. Paste the below code at the command prompt (&gt;) and press enter, as you did above. Or create a new R script (Main menu: File  New File  R Script) and paste code into the Source pane (script editor window). Then, click the Run button in the top-right corner of the Script Editor or use Ctrl+Enter to run code at the cursor location / any selected code. This will execute the code in the Console. Submit the resulting plot to your mentor (from Plot pane (bottom-right): Export  Save as PDF) # load packages into the current session library(aqp) # provides &quot;SoilProfileCollection&quot; object &amp; more library(soilDB) # provides database access methods # get pedons from NASIS selected set test &lt;- fetchNASIS(from = &#39;pedons&#39;) # inspect the result str(test, max.level = 2) # make a profile plot # set margins smaller than default par(mar=c(1,1,1,1)) # make profile plot of selected set, with userpedonid as label plot(test, label=&#39;pedon_id&#39;) 0.7 Proof Follow the one line example below, copy the output, and submit the results to your mentor. This will help us to verify that all of the required packages have been installed. # dump list of packages that are loaded into the current session sessionInfo() 0.8 Additional Support/Optional Readings Spatial Data Analysis and Modeling with R (highly recommended) R-Intro R for Beginners The R Inferno AQP Website and Tutorials Stats for Soil Survey Webinar Soil Data Aggregation using R Webinar "],["ordination.html", "Chapter 1 Numerical Taxonomy and Ordination 1.1 Introduction 1.2 Whirlwind Tour 1.3 Excercises 1.4 Practical Applications", " Chapter 1 Numerical Taxonomy and Ordination 1.1 Introduction Nearly every aspect of soil survey involves the question: Is X more similar to Y or to Z? The quantification of similarity within a collection of horizons, pedons, components, map units, or even landscapes represents an exciting new way to enhance the precision and accuracy of the day-to-day work of soil scientists. After completing this module, you should be able to quantitatively organize objects based on measured or observed characteristics in a consistent and repeatable manner. Perhaps you will find a solution to the long-standing similar or dissimilar question. 1.1.1 Objectives Learn essential vocabulary used in the field of numerical taxonomy. Review some of the literature. Gain experience with R functions and packages commonly used for clustering and ordination. Learn how to create and interpret a distance matrix and appropriate distance metrics. Learn how to create and interpret a dendrogram. Lean the basics and application of hierarchical clustering methods. Lean the basics and application of partitioning clustering methods. Learn the basics and application of ordination methods. Apply skills to a range of data sources for soils and vegetation. Apply techniques from numerical taxonomy to addressing the similar or dissimilar question. Learn some strategies for coping with missing data. 1.2 Whirlwind Tour Most of the examples featured in this whirlwind tour are based on soil data from McGahan, D.G., Southard, R.J, Claassen, V.P. 2009. Plant-available calcium varies widely in soils on serpentinite landscapes. Soil Sci. Soc. Am. J. 73: 2087-2095. These data are available in the dataset sp4 that is built into aqp package for R. 1.2.1 Similarity, Disimilarty, and Distance There are shelves of books and thousands of academic articles describing the theory and applications of clustering and ordination methods. This body of knowledge is commonly described as the field of numerical taxonomy (Sneath and Sokal 1973). Central to this field is the quantification of similarity among individuals based on a relevant set of characteristics. Individuals are typically described as rows of data with a single characteristic per column, together referred to as a data matrix. For example: name clay sand Mg Ca CEC_7 A 21 46 25.7 9.0 23.0 ABt 27 42 23.7 5.6 21.4 Bt1 32 40 23.2 1.9 23.7 Bt2 55 27 44.3 0.3 43.0 Quantitative measures of similarity are more conveniently expressed as distance, or dissimilarity; in part because of convention and in part because of computational efficiency. In the simplest case, dissimilarity can be computed as the shortest distance between individuals in property-space. Another name for the shortest linear distance between points is the Euclidean distance. Evaluated in two dimensions (between individuals \\(p\\) and \\(q\\)), the Euclidean distance is calculated as follows: \\[D(p,q) = \\sqrt{(p_{1} - q_{1})^{2} + (p_{2} - q_{2})^{2}}\\] where \\(p_{1}\\) is the 1st characteristic (or dimension) of individual \\(p\\). There are many other ways to define distance (e.g. distance metrics), but they will be covered later. Using the sand and clay percentages from the data above, dissimilarity is represented as the length of the line connecting any two individuals in property space. The following is a matrix of all pair-wise distances (the distance matrix): A ABt Bt1 Bt2 A 0.0 7.2 12.5 38.9 ABt 7.2 0.0 5.4 31.8 Bt1 12.5 5.4 0.0 26.4 Bt2 38.9 31.8 26.4 0.0 Note that this is the full form of the distance matrix. In this form, zeros are on the diagonal (i.e. the distance between an individual and itself is zero) and the upper and lower triangles are symmetric. The lower triangle is commonly used by most algorithms to encode pair-wise distances. A ABt Bt1 ABt 7.2 Bt1 12.5 5.4 Bt2 38.9 31.8 26.4 Interpretation of the matrix is simple: Individual A is more like ABt than like Bt1. It is important to note that quantification of dissimilarity (distance) among individuals is always relative: X is more like Y, as compared to Z. 1.2.1.1 Distances You Can See: Perceptual Color Difference Simulated redoximorphic feature colors, constrast classes and CIE \\(\\Delta{E_{00}}\\). Details here. 1.2.2 Standardization of Characteristics Euclidean distance doesnt make much sense if the characteristics do not share a common unit of measure or range of values. Nor is it relevant when some characteristics are categorical and some are continuous. For example, distances are distorted if you compare clay (%) and exchangeable Ca (cmol/kg). In this example, exchangeable Ca contributes less to the distance between individuals than clay content, effectively down-weighting the importance of the exchangeable Ca. Typically, characteristics are given equal weight (Sneath and Sokal 1973); however, weighting is much simpler to apply after standardization. Standardization of the data matrix solves the problem of unequal ranges or units of measure, typically by subtraction of the mean and division by standard deviation (z-score transformation). \\[x_{std} = \\frac{x - mean(x)}{sd(x)}\\] There are several other standardization methods covered later. The new data matrix looks like the following: name clay sand Mg Ca CEC_7 A -0.86 0.88 -0.35 1.23 -0.47 ABt -0.45 0.40 -0.55 0.36 -0.63 Bt1 -0.12 0.15 -0.60 -0.59 -0.40 Bt2 1.43 -1.43 1.49 -1.00 1.49 Using the standardized data matrix, distances computed in the property space of clay and exchangeable calcium are unbiased by the unique central tendency or spread of each character. Rarely can the question of dissimilarity be answered with only two characteristics (dimensions). Euclidean distance, however, can be extended to an arbitrary number of \\(n\\) dimensions. \\[D(p,q) = \\sqrt{ \\sum_{i=1}^{n}{(p_{i} - q_{i})^{2}} }\\] In the equation above, \\(i\\) is one of \\(n\\) total characteristics. Imagining what distance looks like is difficult if there are more than three dimensions. Instead, examine the distance matrix calculated using all five characteristics. Rescaling to the interval {0,1}. You can now begin to describe dissimilarity between individuals using an arbitrary number of (relevant) characteristics. You can make statements like The A horizon is roughly 2x more similar to the ABt horizon than it is to the Bt horizon. Although this is a trivial example, the utility of generalizing these methods to soil survey operations should be obvious. 1.2.2.1 Review and Discuss What are the data matrix and distance matrix? What is standardization, and why is it important? What is the largest impediment to creating a distance matrix from NASIS and KSSL data? Key point: Each characteristic is its own dimension in property-space. Sand, clay, and CEC = 3 dimensions. Sand, clay, CEC, OC, and horizon depth = 5 dimensions. Multiple dimensions are simple to define in code but are hard to visualize. The curse of dimensionality. 1.2.3 Missing Data Missing data are a fact of life. Soil scientists are quite familiar with missing lab data (Why didnt we request optical grain counts?) or missing essential NASIS pedon data elements, such as horizon bottom depth, estimated clay fraction, or pH. Nearly all of the methods described in this document are very sensitive to missing data. In other words, they wont work! Following are a couple of possible solutions: Fix the missing data if at all possible, Estimate the missing data values from know relationships to other properties or a group-wise mean or median, or Remove records containing any missing data. 1.2.4 Visualizing Pair-Wise Distances: The Dendrogram Dendrograms are a convenient approximation of pair-wise distances between individuals (after application of hierarchical grouping criteria; more on this later). Dissimilarity between branches is proportional to the level at which branches merge: branching at higher levels (relative to the root of the tree) suggests greater dissimilarity; branching at lower levels suggests greater similarity. Consider the previous example in which distance between individuals was defined in terms of sand and clay percentages. Interpretation is simple. Euclidean distance in property-space is directly proportional to branching height in the corresponding dendrogram. Visualizing the geometry of pair-wise distances in more than three dimensions is difficult. A dendrogram, however, can conveniently summarize a distance matrix created from an arbitrary number of characteristics (dimensions). It is important to note that some information about pair-wise distances is lost or distorted in the dendrogram. Distortion is least near the terminal leaves of the dendrogram. This phenomena is analogous to the distortion generated by a map projection. It is impossible to flatten a higher-dimensional entity to a lower-dimensional form without causing distortion. 1.2.5 Re-arranging a Dendrogram for Clarity The branches of a dendrogram can be rotated like a mobile, so that the final ordering of the terminal leaves approximates an alternate ranking. For example, branches of the following dendrogram (right-hand side) have been rotated to approximate the expected hydrologic gradient from summit to toeslope. 1.2.5.1 Review and Discuss Do you have any questions about dendrogram interpretation? Dendrograms are used extensively in the rest of this chapter. If you were explaining how to interpret a dendrogram to someone, would you start at the roots or leaves? Why? 1.2.6 Cluster Analysis: Finding Groups in Data Cluster analysis is a massive topic that deals with the seemingly simple task of finding useful groups within a dataset. This topic and the methods used are also referred to as unsupervised classification in the fields of remote sensing and GIS. All of the available algorithms will find groups in a given dataset; however, it is up to the subject expert to determine the following: Suitable characteristics and standardization method, Appropriate clustering algorithm, Criteria to determine the right number of clusters, Limitations of the selected algorithm, Interpretation of the final grouping based on subject knowledge, and The possibility of needing to start over at step 1. 1.2.6.1 Using Color to Communicate Results of Clustering or Ordination Note that the widespread use of color in the following examples is not for aesthetic purposes. Colors are convenient for tri-variate data-spaces because you can visually integrate the information into a self-consistent set of classes. 1.2.6.2 Hierarchical Clustering Hierarchical clustering is useful when a full distance matrix is available and the optimal number of clusters is not yet known. This form of clustering creates a data structure that can encode grouping information from one cluster to as many clusters as there are individuals. The expert must determine the optimal place to cut the tree and generate a fixed set of clusters. The results from a hierarchical clustering operation are nearly always presented as a dendrogram. 1.2.6.2.1 Methods There are two main types of hierarchical clustering. Agglomerative: Start with individuals and iteratively combine into larger and larger groups. Divisive: Start with all individuals and iteratively split into smaller and smaller groups. Both methods are strongly influenced by the choice of standardization method and distance metric. Both methods require a full, pair-wise distance matrix as input. This requirement can limit the use of hierarchical clustering to datasets that can be fit into memory. The agglomerative methods also depend on the choice of linkage criterion. Some of these criteria include: Average: usually generates spherical clusters, default in agnes() and recommended by (Kaufman and Rousseeuw 2005), Single linkage: usually generates elongated clusters, Complete linkage: usually generates small, compact clusters, Wards (minimum variance) method, Weighted average (or Gowers) linkage: spherical clusters of roughly equal size, and Flexible strategy: adjustable linkage based on parameter \\(\\alpha\\). Flexible UPGMA (Belbin, Faith, and Milligan 1992): adjustable linkage based on parameter \\(\\beta\\). See (Kaufman and Rousseeuw 2005), (Arkley 1976), (Legendre and Legendre 1998), and agnes() manual page for a detailed description of these linkage criteria. Selection of linkage criteria can be quantitatively evaluated using the cophenetic correlation; and index of how well a dendrogram preserves the original pair-wise distances. This thread on StackExchange has a nice summary of various linkage criteria. I really like these slides by Brian Tibshirani on the topic of agglomerative method selection. More on this later. 1.2.6.2.1.1 Review and Discuss The simplicity and lack of decisions make the divisive method convenient for most work. The top-down approach is similar to the way in which we describe soil morphology and taxonomy. Linkage criteria should be selected based on the hypothesized shape of clusters or prior subject knowledge. When selecting a method, read/think about it; dont just go fishing. Personal opinion: I usually select divisive hierarchical clustering over the other methods: structures seem to be generally more interpretable. 1.2.6.3 Centroid and Medoid (Partitioning) Clustering Centroid and medoid cluster analyses are commonly referred to as k-means-style analysis. K-means, however, is just one of many possible clustering algorithms that partition property-space into a fixed number of groups. These type of algorithms can be applied to very large datasets because they do not rely on the distance matrix. Instead, they are based on an iterative shuffling of group centroids until some criterion is minimized, for example, the mean variance within groups. 1.2.6.3.1 Methods This section describes three (out of many) of the most important partitioning-type algorithms. K-means: Groups of individuals are partitioned around newly created centroids. Resulting clusters approximately spherical and contain an approximately equal number of individuals. K-medoids: Groups of individuals are partitioned around selected medoids. Fuzzy clustering: Individuals are assigned a fuzzy membership value for each partition of property-space. All of these methods are sensitive to the type of standardization applied to the characteristics. These methods rely on iterative minimization of one or more criteria; therefore, each clustering run may generate slightly different output. Most implementations re-run the algorithm until it stabilizes. 1.2.6.3.1.1 Review and Discuss What is the difference between a medoid and a centroid? Can you think of a way in which both concepts could be applied to the grouping of soils data? medoids are tied to individuals, centroids are hypothetical (calculated) Fuzzy clustering is also referred to as soft clustering, while the other two methods are referred to as hard clustering. Sometimes, using both can be helpful, especially if individuals straddle the line between groups. Each method has its own strength and weakness, for example here is a nice summary of the limitations of k-means. 1.2.7 Ordination: Visualization in a Reduced Space Humans are generally quite good at extracting spatial patterns, almost instantly, from two dimensional fields: faces, written language, etc. Sadly, this ability does not extend beyond two or three dimensions. The term ordination refers to a suite of methods that project coordinates in a high-dimensional space into suitable coordinates in a low-dimensional (reduced) space. Map projections are a simple form of ordination: coordinates from the curved surface of the Earth are projected to a two-dimensional plane. As with any projection, there are assumptions, limitations, and distortions. Carl Sagan gives a beautiful demonstration of this concept using shadows, in this excerpt from Cosmos. Here is another excellent demonstration based on handwriting recognition. Hole and Hironaka (1960) were some of the first pedologists to apply ordination methods to soils data. The main figure from their classic paper was hand-drawn, based on a physical model (constructed from wooden dowels and spheres!) of the ordination. 1.2.7.1 Major Types of Ordination Of the many possible ordination methods, there are two major types to keep in mind: Constrained ordination: coordinates in the reduced space are subject to some kind of constraint (more rigid, simple interpretation). Principal component analysis (PCA) is one of the simplest and most widely used ordination methods. The reduced space (principal components) are defined by linear combinations of characteristics. Unconstrained ordination: coordinates in the reduced space are not subject to any kind of constraint (more flexible, less interpretable). Non-metric multidimensional scaling (nMDS) attempts to generate a reduced space that minimizes distortion in proportional similarity; i.e., similar individuals are near each other in the reduced space, dissimilar individuals are farther apart. The non-metric adjective implies that exact distances are not preserved. See (Legendre and Legendre 1998) for a comprehensive listing of methods, associated theory, and ecological applications. 1.2.7.2 An Example of nMDS Applied to Soil Data The following example is based on a data matrix containing lab measurements of clay fraction, sand fraction, exchangeable Ca, exchangeable Mg, and CEC measured by NH4-Ac at pH 7. name clay sand Mg Ca CEC_7 A -0.41 0.21 0.06 0.44 -0.23 ABt 0.04 -0.07 -0.06 -0.13 -0.38 Bt1 0.41 -0.21 -0.09 -0.74 -0.16       Note that distances between individuals, within clusters, and between clusters is more apparent in the nMDS representation of the distance matrix. Similar information is embedded in the dendrogram but it is not as intuitive. 1.2.7.2.1 Interpreting the Results We can conveniently annotate the results of an ordination with contextual information, such as the approximate trends in clay content or CEC. Note that ordination methods represent a flattening of multi-dimensional data space, and in the case of nMDS, preserve proportional (vs. exact) pair-wise distances. Therefore, it is quite common for surfaces (the contours below) fit to the 2D ordination to have complex patterns. Putting the clustering results into context is important: recall that we are working with individuals that represent genetic horizons that have been clustered according to 5 physical / chemical properties (characteristics). Differences in CEC by NH4-Ac are one of the strongest contributors to the pair-wise distances and overall clustering structure. 1.2.8 Review and Discuss Which visualization of the distance matrix was simpler to interpret: Dendrogram or ordination by nMDS? Do you have any questions about the figures? Do you have any guesses on what the clusters represent? 1.2.9 Pair-Wise Distances Between Soil Profiles This is a complex topic, described in a supplemental set of slides. If you want for more detailed information, see this relevant paper. 1.2.10 Final Discussion Missing data strategy Meaningful characteristics Standardization of characteristics Distance metric Clustering algorithm Number of clusters Application to soil survey and ESD 1.3 Excercises This is the fun part. 1.3.1 Set Up the R Session Install R packages as needed. Open a new R script file to use as you follow along. # load libraries library(aqp) library(soilDB) library(sharpshootR) library(cluster) library(ape) library(RColorBrewer) library(vegan) library(MASS) library(colorspace) library(viridis) 1.3.1.1 Data Sources Most of the examples used in the following exercises come from these sources: Built-in data sets from the aqp and soilDB packages (sp4, gopheridge, and loafercreek). Results from fetchNASIS(): pedon data from the local NASIS selected set. Results from fetchKSSL(): lab characterization data from the SoilWeb snapshot. Results from fetchOSD(): basic morphologic and taxonomic data from the SoilWeb snapshot. Results from SDA_query(): live SSURGO spatial and tabular data from Soil Data Access Data from SSR 2, as CSV, downloaded from class GitHub site In most cases, you can edit the examples and swap-in just about any data that are in a SoilProfileCollection object. For example, pedons from your local NASIS selected set can be loaded with fetchNASIS(). 1.3.1.1.1 Try it! Tinker with some SoilProfileCollection objects. Get some data using one of the methods listed above. If you need help, see the manual pages for examples (?fetchKSSL) or the SoilProfileCollection tutorial. Determine the number of profiles and horizons within the collection. View and extract some site and horizon attributes. Generate some soil profile sketches. 1.3.2 Evaluating Missing Data The aqp package provides two functions for checking the fraction of missing data within a SoilProfileCollection object. The first function (evalMissingData) generates an index that ranges from 0 (all missing) to 1 (all present) for each profile. This index can be used to subset or rank profiles for further investigation. The second function (missingDataGrid) creates a visualization of the fraction of data missing within each horizon. Both functions can optionally filter-out horizons that dont typically have data, for example Cr, Cd, and R horizons. The following examples are based on the gopheridge sample dataset. evalMissingData # example data data(&quot;gopheridge&quot;, package = &quot;soilDB&quot;) # compute data completeness gopheridge$data.complete &lt;- evalMissingData(gopheridge, vars = c(&#39;clay&#39;, &#39;sand&#39;, &#39;phfield&#39;), name = &#39;hzname&#39;, p = &#39;Cr|R|Cd&#39;) # check range in missing data summary(gopheridge$data.complete) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.0000 0.0000 0.2143 0.4672 1.0000 1.0000 # rank new.order &lt;- order(gopheridge$data.complete) # plot along data completeness ranking par(mar=c(3,0,1,1)) plot(gopheridge, plot.order=new.order, print.id=FALSE, name=&#39;&#39;) # add axis, note re-ordering of axis labels axis(side=1, at=1:length(gopheridge), labels = round(gopheridge$data.complete[new.order], 2), line=-2, cex.axis=0.65, las=2) title(&#39;Gopheridge pedons sorted according to data completeness (clay, sand, pH)&#39;) missingDataGrid # view missing data as a fraction res &lt;- missingDataGrid(gopheridge, max_depth=100, vars=c(&#39;clay&#39;, &#39;sand&#39;, &#39;phfield&#39;), filter.column=&#39;hzname&#39;, filter.regex = &#39;Cr|R|Cd&#39;, main=&#39;Fraction of missing data (clay, sand, pH)&#39;, cols = viridis(10)) # plot figure print(res$fig) # check results head(res$summary) ## peiid clay sand phfield ## 1 1137354 0 100 100 ## 2 1147151 0 0 100 ## 3 1147190 0 0 100 ## 4 242808 29 29 0 ## 5 252851 29 29 29 ## 6 268791 0 0 0 For now, extract those profiles that have a complete set of field-described clay, sand, or pH values for later use. # be sure to read the manual page for this function gopheridge.complete &lt;- subset(gopheridge, data.complete &gt; 0.99) # another way idx &lt;- which(gopheridge$data.complete &gt; 0.99) gopheridge.complete &lt;- gopheridge[idx, ] # looks good par(mar=c(0,0,3,1)) plot(gopheridge.complete, color=&#39;clay&#39;, id.style=&#39;side&#39;, label=&#39;pedon_id&#39;) 1.3.3 More on the Distance Matrix and How to Make One The following three functions are essential to the creation of a distance matrix: dist(): This function is in base R, is simple and fast, and has a limited number of distance metrics. daisy(): This function is in cluster package, has a better selection of distance metrics, and has simple standardization. Much more convenient than dist(). vegdist(): This function is in vegan package, has many distance metrics, and is primarily designed for species composition data. The following is a short demonstration: # get some example data from the aqp package data(&#39;sp4&#39;, package = &#39;aqp&#39;) # subset select rows and columns sp4 &lt;- sp4[1:4, c(&#39;name&#39;, &#39;clay&#39;, &#39;sand&#39;, &#39;Mg&#39;, &#39;Ca&#39;, &#39;CEC_7&#39;)] row.names(sp4) &lt;- sp4$name # compare distance functions # Euclidean distance, no standardization round(dist(sp4[, -1], method = &#39;euclidean&#39;)) ## A ABt Bt1 ## ABt 8 ## Bt1 15 7 ## Bt2 48 44 39 # Euclidean distance, standardization round(daisy(sp4[, -1], stand = TRUE, metric = &#39;euclidean&#39;), 2) ## Dissimilarities : ## A ABt Bt1 ## ABt 1.45 ## Bt1 2.73 1.36 ## Bt2 6.45 5.65 4.91 ## ## Metric : euclidean ## Number of objects : 4 # Gower&#39;s generalized distance metric (includes standardization) round(vegdist(sp4[, -1], method = &#39;gower&#39;), 2) ## A ABt Bt1 ## ABt 0.19 ## Bt1 0.32 0.16 ## Bt2 0.96 0.84 0.69 1.3.3.1 Distance Calculations with Categorical Data The following example is excerpted from A Novel Display of Categorical Pedon Data. This example illustrates an application of clustering binary data (presence or absence of a diagnostic feature). Internally, the diagnosticPropertyPlot() function uses the daisy() function to compute pair-wise distances using the general dissimilarity coefficient of Gower (Gower 1971). A concise summary of this distance metric is in (Kaufman and Rousseeuw 2005). # load some example NASIS data data(loafercreek, package=&#39;soilDB&#39;) # cut-down to a subset, first 20 pedons loafercreek &lt;- loafercreek[1:20, ] # get depth class sdc &lt;- getSoilDepthClass(loafercreek) site(loafercreek) &lt;- sdc # diagnostic properties to consider, no need to convert to factors v &lt;- c(&#39;lithic.contact&#39;, &#39;paralithic.contact&#39;, &#39;argillic.horizon&#39;, &#39;cambic.horizon&#39;, &#39;ochric.epipedon&#39;, &#39;mollic.epipedon&#39;, &#39;very.shallow&#39;, &#39;shallow&#39;, &#39;mod.deep&#39;, &#39;deep&#39;, &#39;very.deep&#39;) # do the analysis and save the results to object &#39;x&#39; x &lt;- diagnosticPropertyPlot(loafercreek, v, k=5, grid.label=&#39;bedrckkind&#39;, dend.label = &#39;taxonname&#39;) If you are wondering what is in the object x, the str() function or manual page (?diagnosticPropertyPlot) can help. 1.3.4 Hierachrical Clustering The go-to functions for hierarchical clustering are as follows: hclust(): This function is agglomerative, is in base R, requires a distance matrix, and implements most of the commonly used linkage criteria. agnes(): This function is agglomerative, is in cluster package, can perform standardization and distance calculations, and implements more linkage criteria. diana(): This function is divisive, is in cluster package, can perform standardization and distance calculations. 1.3.4.1 Basic Agglomerative Hierarchical Clustering with hclust The hclust() function and resulting hclust-class objects are simple to use, but limited. # re-make data, this time with all profiles data(&#39;sp4&#39;, package = &#39;aqp&#39;) sp4 &lt;- sp4[, c(&#39;name&#39;, &#39;clay&#39;, &#39;sand&#39;, &#39;Mg&#39;, &#39;Ca&#39;, &#39;CEC_7&#39;)] # distance matrix d &lt;- daisy(sp4[, -1], metric = &#39;euclidean&#39;, stand = TRUE) # hierachical clustering with base function hclust sp4.h &lt;- hclust(d, method = &#39;ward.D&#39;) sp4.h$labels &lt;- sp4$name # plot with basic plotting method... not many options here par(mar=c(2,4,2,2)) plot(sp4.h, font=2, cex=0.85) # ID clusters after cutting tree rect.hclust(sp4.h, 4) 1.3.4.2 Better Plots via ape Package This example uses a different approach to plotting based on functions and classes from the ape package. # re-make data, this time with all profiles data(&#39;sp4&#39;, package = &#39;aqp&#39;) sp4 &lt;- sp4[, c(&#39;name&#39;, &#39;clay&#39;, &#39;sand&#39;, &#39;Mg&#39;, &#39;Ca&#39;, &#39;CEC_7&#39;)] # distance matrix d &lt;- daisy(sp4[, -1], metric = &#39;euclidean&#39;, stand = TRUE) # divising clustering dd &lt;- diana(d) # convert to ape class, via hclust class h &lt;- as.hclust(dd) h$labels &lt;- sp4$name p &lt;- as.phylo(h) # define some nice colors col.set &lt;- brewer.pal(9, &#39;Set1&#39;) # cut tree into 4 groups groups &lt;- cutree(h, 4) # make color vector based on groups cols &lt;- col.set[groups] The plot methods for phylo class objects are quite flexible. Be sure to see the manual page ?plot.phylo. par(mar=c(1,1,1,1), mfcol=c(2,2)) plot(p, label.offset=0.125, direction=&#39;right&#39;, font=1, cex=0.85, main=&#39;dendrogram&#39;) tiplabels(pch=15, col=cols) plot(p, type=&#39;radial&#39;, font=1, cex=0.85, main=&#39;radial&#39;) tiplabels(pch=15, col=cols) plot(p, type=&#39;fan&#39;, font=1, cex=0.85, main=&#39;fan&#39;) tiplabels(pch=15, col=cols) plot(p, type=&#39;unrooted&#39;, font=1, cex=0.85, main=&#39;unrooted&#39;) tiplabels(pch=15, col=cols) 1.3.4.3 Evaluation of Dendrogram Representation Re-visiting our sample data from before, develop hierarchical clusterings using several strategies (methods / linkage criteria). # re-make data, this time with all profiles data(&#39;sp4&#39;, package = &#39;aqp&#39;) sp4 &lt;- sp4[, c(&#39;name&#39;, &#39;clay&#39;, &#39;sand&#39;, &#39;Mg&#39;, &#39;Ca&#39;, &#39;CEC_7&#39;)] # distance matrix d &lt;- daisy(sp4[, -1], metric = &#39;euclidean&#39;, stand = TRUE) # hierarchical clustering based on several strategies # agglomerative h.avg &lt;- agnes(d, method=&#39;average&#39;) h.single &lt;- agnes(d, method=&#39;single&#39;) h.complete &lt;- agnes(d, method=&#39;complete&#39;) h.ward &lt;- agnes(d, method=&#39;ward&#39;) h.flexible &lt;- agnes(d, method=&#39;gaverage&#39;, par.method = 0.01) # divisive h.div &lt;- diana(d) The correlation between original distance matrix and cophenetic distance matrix is a reasonable index of how faithfully a dendrogram preserves the original pair-wise distances. # agglomerative hierarchical clustering with various linkage criteria corr.avg &lt;- cor(d, cophenetic(h.avg)) corr.single &lt;- cor(d, cophenetic(h.single)) corr.complete &lt;- cor(d, cophenetic(h.complete)) corr.ward &lt;- cor(d, cophenetic(h.ward)) corr.flexible &lt;- cor(d, cophenetic(h.flexible)) # divisive hierarchical clustering corr.div &lt;- cor(d, cophenetic(h.div)) Combine the results into a table for quick comparison. Note that the agnes and diana functions provide an agglomerative / divisive coefficient that can be used to evaluate clustering efficiency (e.g. cluster size and compactness). Depending on the application, one metric may be more informative than the other. res &lt;- data.frame( method=c(&#39;average&#39;, &#39;single&#39;, &#39;complete&#39;, &#39;ward&#39;, &#39;flexible UPGMA&#39;, &#39;divisive&#39;), cophenetic.correlation=c(corr.avg, corr.single, corr.complete, corr.ward, corr.flexible, corr.div), agg_div.coefficient=c(h.avg$ac, h.single$ac, h.complete$ac, h.ward$ac, h.flexible$ac, h.div$dc) ) # re-order res &lt;- res[order(res$cophenetic.correlation, decreasing = TRUE), ] method cophenetic.correlation agg_div.coefficient average 0.840 0.787 flexible UPGMA 0.840 0.778 single 0.784 0.613 complete 0.759 0.879 ward 0.756 0.894 divisive 0.703 0.874 Investigate differences graphically: Ive ranked according to the frequency withwhich I use the various methods. par(mar=c(0,0.25,1.5,0.25), mfrow=c(2,3)) plot(as.phylo(as.hclust(h.div)), label.offset=0.125, direction=&#39;right&#39;, font=1, cex=0.65, main=&#39;1. Divisive&#39;) tiplabels(pch=15, col=col.set[cutree(h.div, 4)]) plot(as.phylo(as.hclust(h.ward)), label.offset=0.125, direction=&#39;right&#39;, font=1, cex=0.65, main=&#39;2. Ward&#39;) tiplabels(pch=15, col=col.set[cutree(h.ward, 4)]) plot(as.phylo(as.hclust(h.flexible)), label.offset=0.125, direction=&#39;right&#39;, font=1, cex=0.65, main=&#39;3. Flexible (0.01)&#39;) tiplabels(pch=15, col=col.set[cutree(h.flexible, 4)]) plot(as.phylo(as.hclust(h.avg)), label.offset=0.125, direction=&#39;right&#39;, font=1, cex=0.65, main=&#39;4. Average&#39;) tiplabels(pch=15, col=col.set[cutree(h.avg, 4)]) plot(as.phylo(as.hclust(h.single)), label.offset=0.125, direction=&#39;right&#39;, font=1, cex=0.65, main=&#39;(never) Single&#39;) tiplabels(pch=15, col=col.set[cutree(h.single, 4)]) plot(as.phylo(as.hclust(h.complete)), label.offset=0.125, direction=&#39;right&#39;, font=1, cex=0.65, main=&#39;(never) Complete&#39;) tiplabels(pch=15, col=col.set[cutree(h.complete, 4)]) 1.3.4.3.1 More on the Flexible UPGMA method Test the flexible UPGMA method (Belbin, Faith, and Milligan 1992) by iterating over possible values for \\(\\beta\\). Looks like a value near 0.01 would be ideal (e.g. highest cophenetic correlation). Interestingly, this is very close to the cophenetic correlation associated with the average linkage criteria. # init a sequence spanning -1 to 1 beta &lt;- seq(from=-1, to=1, length.out = 100) # init an empty vector to store results r &lt;- vector(mode=&#39;numeric&#39;, length = length(beta)) # iterate over values of beta and compute cophenetic correlation for(i in 1:length(r)) { r[i] &lt;- cor(d, cophenetic(agnes(d, method=&#39;gaverage&#39;, par.method = beta[i]))) } # plot par(mar=c(5,5,1,1)) plot(beta, r, type=&#39;l&#39;, xlab=&#39;beta parameter&#39;, ylab=&#39;cophenetic correlation&#39;, pch=16, las=1) # locate the max coph. corr. idx &lt;- which.max(r) # mark this point and label points(beta[idx], r[idx], col=&#39;red&#39;, cex=2, lwd=2) text(beta[idx], r[idx], labels = round(beta[idx], 3), pos=4) 1.3.4.4 Comparison of Dendrograms The following example is rather basic. Many more possibilities are available in the dendextend package. # load sample dataset from aqp package data(sp3) # promote to SoilProfileCollection depths(sp3) &lt;- id ~ top + bottom # compute dissimilarity using different sets of variables # note that these are rescaled to the interval [0,1] d.1 &lt;- profile_compare(sp3, vars=c(&#39;clay&#39;, &#39;L&#39;), k=0, max_d=100, rescale.result=TRUE) # cluster via divisive hierarchical algorithm # convert to &#39;phylo&#39; class p.1 &lt;- as.phylo(as.hclust(diana(d.1))) # graphically compare diana() to agnes() using d.2 dueling.dendrograms(as.phylo(as.hclust(diana(d.1))), as.phylo(as.hclust(agnes(d.1, method=&#39;average&#39;))), lab.1=&#39;divisive&#39;, lab.2=&#39;agglomerative: average linkage&#39;) 1.3.5 Centroid and Medoid (Partitioning) Clustering The following creates simulated data for demonstration purposes, representing two populations: mean = 0, sd = 0.3 mean = 1, sd = 0.3 # nice colors for later col.set &lt;- brewer.pal(9, &#39;Set1&#39;) # 2D example x &lt;- rbind( matrix(rnorm(100, mean = 0, sd = 0.3), ncol = 2), matrix(rnorm(100, mean = 1, sd = 0.3), ncol = 2) ) colnames(x) &lt;- c(&quot;x&quot;, &quot;y&quot;) 1.3.5.1 Hard Classes 1.3.5.1.1 K-Means It is important to note that the k-means algorithm is sensitive to the initial selection of centroid locations (typically random). The default behavior of the kmeans() function does not attempt to correct for this limitation. Note that cluster assignment and centroid vary across runs (panels in the figure below). par(mfrow=c(3,3), mar=c(1,1,1,1)) for(i in 1:9) { cl &lt;- kmeans(x, centers=3) plot(x, col = col.set[cl$cluster], axes=FALSE) grid() points(cl$centers, col = col.set, pch = 8, cex = 2, lwd=2) box() } Setting the nstart argument (number of random starts) to a value great than 1 (10 is ideal) will ensure that the final clustering configuration will remain stable between runs. Note that the cluster ID (color) will vary between runs, however, with nstart=10 the overal configuration remains the same. par(mfrow=c(3,3), mar=c(1,1,1,1)) for(i in 1:9) { cl &lt;- kmeans(x, centers=3, nstart = 10, iter.max = 100) plot(x, col = col.set[cl$cluster], axes=FALSE) grid() points(cl$centers, col = col.set, pch = 8, cex = 2, lwd=2) box() } 1.3.5.1.2 K-Medoids The cluster package provides two interfaces to the k-medoids algorithm: pam(): small to medium sized data sets clara(): optmized for larger data sets A quick example of using pam() to identify an increasing number of clusters. par(mfrow=c(2,3), mar=c(1,1,1,1)) for(i in 2:7) { cl &lt;- pam(x, k = i, stand = TRUE) plot(x, col = col.set[cl$clustering], axes=FALSE) grid() points(cl$medoids, col = col.set, pch = 0, cex = 2, lwd=2) box() } 1.3.5.2 Fuzzy Clusters Clustering results are in the form of class membership; values ranging between 0 and 1. This means that group membership is a continuum vs. the hard classes assigned by k-means or k-medoids. The mixture of class membership in the example below is conveniently expressed using proportions of red, green, and blue. # re-make data, this time with all profiles data(&#39;sp4&#39;, package = &#39;aqp&#39;) sp4.std &lt;- data.frame(sp4[, c(&#39;id&#39;, &#39;name&#39;, &#39;top&#39;, &#39;bottom&#39;)], scale( sp4[, c(&#39;Mg&#39;, &#39;Ca&#39;)])) # perform fuzzy clustering cl &lt;- fanny(sp4.std[, c(&#39;Mg&#39;, &#39;Ca&#39;)], k = 3, stand = FALSE) # get membership matrix m &lt;- cl$membership # convert to colors by interpreting membership as R,G,B proportions cols &lt;- rgb(m) # setup plot par(mar=c(4,4,0,0)) plot(sp4.std$Mg, sp4.std$Ca, asp=1, ylab=&#39;Exchangeable Mg (cmol/kg), Standardized&#39;, xlab=&#39;Exchangeable Ca (cmol/kg), Standardized&#39;, type=&#39;n&#39;) abline(h=0, v=0, col=&#39;black&#39;) grid() # add original obs points(sp4.std$Mg, sp4.std$Ca, bg=cols, col=&#39;black&#39;, cex=1.5, pch=21) Save the RGB color representation of cluster membership to the source data.frame and convert to SoilProfileCollection. sp4.std$colors &lt;- cols depths(sp4.std) &lt;- id ~ top + bottom par(mar=c(0,0,0,0)) plot(sp4.std, color=&#39;colors&#39;, cex.names=0.75) title(&#39;Fuzzy Clustering Results in Context&#39;, line=-1) From the source: Of the 11 parent materials, 9 were serpentinites. The parent materials in Napa and Tehama Counties were quite different from each other and from those of the nine other sites. Neither had parent rock that contained serpentine minerals. They were, therefore, not serpentinites. The Napa County parent material contained dominantly vermiculite and albite and had minor amounts of Ca-bearing clino-pyroxene. The Tehama County parent material was dominated by grossularite, which is a calcsilicate ugrandite garnet, and had subdominant amounts of the Ca-bearing sorosilicate, pumpellyite, and Ca-bearing clinopyroxene. The rocks from the Shasta and Kings County sites were serpentinite, dominated by serpentine minerals. They had minor amounts of Ca-bearing accessory minerals (calcic clinoamphibole [tremolite] and calcsilicate ugrandite garnet [andradite]). The seven other parent materials were serpentinites and exhibited, at most, trace amounts of Ca-bearing minerals. 1.3.5.3 How Many Clusters? There is no simple answer to the question How many clusters are in my data? Some metrics, however, can be used to help estimate a reasonable number of clusters. The mean silhouette width is a useful index of cluster compactness relative to neighbor clusters (Rousseeuw 1987). Larger silhouette widths suggest tighter grouping. # re-make data, this time with all profiles data(&#39;sp4&#39;, package = &#39;aqp&#39;) sp4.std &lt;- data.frame(sp4[, c(&#39;id&#39;, &#39;name&#39;, &#39;top&#39;, &#39;bottom&#39;)], scale( sp4[, c(&#39;Mg&#39;, &#39;Ca&#39;)])) # perform hard clustering sil.widths &lt;- vector(mode=&#39;numeric&#39;) for(i in 2:10) { cl &lt;- pam(sp4.std[, c(&#39;Mg&#39;, &#39;Ca&#39;)], k = i, stand = FALSE) sil.widths[i] &lt;- cl$silinfo$avg.width } par(mar=c(4,4,3,1)) plot(sil.widths, type=&#39;b&#39;, xlab=&#39;Number of Clusters&#39;, ylab=&#39;Average Silhouette Width&#39;, las=1, lwd=2, col=&#39;RoyalBlue&#39;, cex=1.25, main=&#39;Finding the &quot;Right&quot; Number of Clusters&#39;) grid() According to this metric, it looks like 3 clusters is reasonable. Again, this is a judgement callmost decisions related to clustering algorithm selection and the optimal number of clusters are somewhat subjective. # perform fuzzy clustering cl &lt;- pam(sp4.std[, c(&#39;Mg&#39;, &#39;Ca&#39;)], k = 3, stand = FALSE) # setup plot par(mar=c(4,4,0,0)) plot(sp4.std$Mg, sp4.std$Ca, asp=1, ylab=&#39;Exchangeable Mg (cmol/kg), Standardized&#39;, xlab=&#39;Exchangeable Ca (cmol/kg), Standardized&#39;, type=&#39;n&#39;) abline(h=0, v=0, col=&#39;black&#39;) grid() # add original obs points(sp4.std$Mg, sp4.std$Ca, bg=cl$clustering, col=&#39;black&#39;, cex=1.25, pch=21) TODO: other cluster metrics packages 1.3.5.4 Ordination 1.3.5.4.1 Principal Component Analysis A simple, constrained ordination based on variance. This method does not use the distance matrix, rather it seeks to find a new set of axes that describe maximum variance via linear combinations of characteristics. Standardization is essential. # re-make data, this time with all profiles data(&#39;sp4&#39;, package = &#39;aqp&#39;) sp4 &lt;- sp4[, c(&#39;name&#39;, &#39;clay&#39;, &#39;sand&#39;, &#39;Mg&#39;, &#39;Ca&#39;, &#39;CEC_7&#39;)] sp4.scaled &lt;- data.frame(name=sp4[, 1], round(scale( sp4[, -1]), 2)) # PCA # note that we are leaving out the first column: the horizon names # note the syntax used to extract the principal components # note that PCA doesn&#39;t use the distance matrix pca &lt;- predict(princomp(sp4.scaled[, -1])) ## perform clustering to highlight structure in the PCA # distance matrix d &lt;- dist(sp4.scaled[, -1]) m &lt;- as.matrix(d) dimnames(m) &lt;- list(sp4.scaled$name, sp4.scaled$name) d &lt;- as.dist(m) # dendrogram from divisive clustering dd &lt;- diana(d) h &lt;- as.hclust(dd) p &lt;- as.phylo(h) # define colors based on cutting a divisive hierarchical clustering into 4 groups cols &lt;- brewer.pal(9, &#39;Set1&#39;)[cutree(h, 4)] # plot first 2 PC plot(pca[, 1:2], asp=1, type=&#39;n&#39;, axes=FALSE, xlab=&#39;&#39;, ylab=&#39;&#39;, main=&quot;Principal Components 1 and 2&quot;) grid() text(pca[, 1:2], sp4.scaled$name, cex=0.75, col=cols, font=2) box() 1.3.5.5 Sammons Non-linear Mapping Simple interface to nMDS, input is a distance matrix. Note that this algorithm will fail if there are 0s or ties within the distance matrix. See ?sammon for details. # re-make data, this time with all profiles data(&#39;sp4&#39;, package = &#39;aqp&#39;) sp4 &lt;- sp4[, c(&#39;name&#39;, &#39;clay&#39;, &#39;sand&#39;, &#39;Mg&#39;, &#39;Ca&#39;, &#39;CEC_7&#39;)] sp4.scaled &lt;- data.frame(name=sp4[, 1], round(scale( sp4[, -1]), 2)) # distance matrix d &lt;- dist(sp4.scaled[, -1]) m &lt;- as.matrix(d) dimnames(m) &lt;- list(sp4.scaled$name, sp4.scaled$name) d &lt;- as.dist(m) # dendrogram from divisive clustering dd &lt;- diana(d) h &lt;- as.hclust(dd) p &lt;- as.phylo(h) # define colors based on cutting a divisive hierarchical clustering into 4 groups cols &lt;- brewer.pal(9, &#39;Set1&#39;)[cutree(h, 4)] # nMDS from distance matrix s &lt;- sammon(d) # plot par(mar=c(3,1,3,1)) plot(s$points, asp=1, type=&#39;n&#39;, axes=FALSE, xlab=&#39;&#39;, ylab=&#39;&#39;, main=&quot;nMDS by Sammon&#39;s Non-Linear Mapping&quot;) # abline(v=0, h=0, col=&#39;black&#39;) grid() text(s$points, rownames(s$points), cex=0.75, col=cols, font=2) box() 1.3.5.6 nMDS with the vegan Package The following example is quite brief. See the Introduction to ordination in vegan vignette for some excellent worked examples and ecological interpretation. The vegan package FAQ is another excellent resource. Numerical Ecology with R can be used as both reference and learning resource. The metaMDS() function from the vegan package provides a convenience function that automates most of the steps required to create an oridination. # re-make data, this time with all profiles data(&#39;sp4&#39;, package = &#39;aqp&#39;) sp4 &lt;- sp4[, c(&#39;name&#39;, &#39;clay&#39;, &#39;sand&#39;, &#39;Mg&#39;, &#39;Ca&#39;, &#39;CEC_7&#39;)] sp4.scaled &lt;- data.frame(name=sp4[, 1], round(scale( sp4[, -1]), 2)) # define colors based on natural groupings cols &lt;- brewer.pal(9, &#39;Set1&#39;) # distance calc + ordination s &lt;- metaMDS(sp4.scaled[, -1], distance = &#39;gower&#39;, autotransform = FALSE, wascores=FALSE) ## this is used to generate 4 classes from a divisive hierarchical clustering # manually compute distance matrix d &lt;- dist(sp4.scaled[, -1]) m &lt;- as.matrix(d) dimnames(m) &lt;- list(sp4.scaled$name, sp4.scaled$name) d &lt;- as.dist(m) # dendrogram from divisive clustering dd &lt;- diana(d) h &lt;- as.hclust(dd) # define colors based on cutting a divisive hierarchical clustering into 4 groups cols &lt;- brewer.pal(9, &#39;Set1&#39;)[cutree(h, 4)] # plot ordination par(mar=c(3,1,3,1)) fig &lt;- ordiplot(s, type=&#39;none&#39;, cex.axis=0.75, axes=FALSE, xlab=&#39;&#39;, ylab=&#39;&#39;, main=&#39;nMDS by metaMDS()&#39;) abline(h=0, v=0, lty=2, col=&#39;grey&#39;) text(fig$sites, sp4$name, cex=0.75, font=2, col=cols) # ordicluster(fig, agnes(daisy(sp4.scaled[, -1]), method=&#39;ward&#39;), prune=3, col = &quot;orange&quot;) box() 1.3.5.7 Rotations procrustes, etc. # https://ncss-tech.github.io/AQP/aqp/color-contrast.html 1.4 Practical Applications Before you work through the following examples, you should review the SoilProfileCollection object tutorial. 1.4.1 Pair-Wise Distances Between Soil Profiles # init example data data(sp4) depths(sp4) &lt;- id ~ top + bottom # eval dissimilarity: # using Ex-Ca:Mg and CEC at pH 7 # with no depth-weighting (k=0) # to a maximum depth of 40 cm d &lt;- profile_compare(sp4, vars=c(&#39;ex_Ca_to_Mg&#39;, &#39;CEC_7&#39;), k=0, max_d=40) # check distance matrix: round(d, 1) ## Dissimilarities : ## colusa glenn kings mariposa mendocino napa san benito shasta shasta-trinity ## glenn 13.5 ## kings 16.0 12.7 ## mariposa 8.4 11.3 16.5 ## mendocino 11.5 8.0 16.4 15.0 ## napa 30.4 24.1 29.4 29.2 21.6 ## san benito 25.7 20.6 26.3 28.2 15.8 18.0 ## shasta 17.2 13.3 8.7 17.6 17.1 33.7 22.2 ## shasta-trinity 6.4 16.6 22.3 9.6 16.5 29.8 27.2 23.3 ## tehama 28.7 22.9 27.9 27.3 20.0 8.8 15.1 31.4 27.9 ## ## Metric : mixed ; Types = I, I ## Number of objects : 10 # cluster via divisive method clust &lt;- diana(d) # vizualize dissimilarity matrix via hierarchical clustering par(mar=c(0,0,3,1)) plotProfileDendrogram(sp4, clust, dend.y.scale = max(d), scaling.factor = (1/max(d) * 10), y.offset = 2.25, width=0.25, cex.names=0.6, color=&#39;ex_Ca_to_Mg&#39;, col.label=&#39;Exchageable Ca to Mg Ratio&#39;) 1.4.2 Pair-Wise Distances Between Soil Series The following figures are a preview of some new functionality planned for SoilWeb/SDE. These related tutorials cover similar material in greater detail: Competing Soil Series Querying Soil Series Data The fetchOSD function can return additional summaries tabulated from climate data, MLRA boundaries, SSURGO, and much more with the extended=TRUE argument. Lets experiment with distances computed from annual climate data and hillslope position. # soil series from around CONUS soils &lt;- c(&#39;redding&#39;, &#39;pentz&#39;, &#39;willows&#39;, &#39;yolo&#39;, &#39;hanford&#39;, &#39;cecil&#39;, &#39;sycamore&#39;, &#39;KLAMATH&#39;, &#39;drummer&#39;, &#39;musick&#39;, &#39;zook&#39;) s &lt;- fetchOSD(soils, extended = TRUE) # note additional data, packed into a list str(s, 1) ## List of 14 ## $ SPC :Formal class &#39;SoilProfileCollection&#39; [package &quot;aqp&quot;] with 9 slots ## $ competing :&#39;data.frame&#39;: 57 obs. of 3 variables: ## $ geog_assoc_soils:&#39;data.frame&#39;: 75 obs. of 2 variables: ## $ geomcomp :&#39;data.frame&#39;: 9 obs. of 9 variables: ## $ hillpos :&#39;data.frame&#39;: 10 obs. of 8 variables: ## $ mtnpos :&#39;data.frame&#39;: 2 obs. of 9 variables: ## $ terrace :&#39;data.frame&#39;: 8 obs. of 5 variables: ## $ flats :&#39;data.frame&#39;: 7 obs. of 7 variables: ## $ pmkind :&#39;data.frame&#39;: 19 obs. of 5 variables: ## $ pmorigin :&#39;data.frame&#39;: 44 obs. of 5 variables: ## $ mlra :&#39;data.frame&#39;: 75 obs. of 4 variables: ## $ climate.annual :&#39;data.frame&#39;: 88 obs. of 12 variables: ## $ climate.monthly :&#39;data.frame&#39;: 264 obs. of 14 variables: ## $ soilweb.metadata:&#39;data.frame&#39;: 17 obs. of 2 variables: 1.4.2.1 Annual Climate Data The vizAnnualClimate function (sharpshootR package) arranges percentiles of annual climate summaries according to divisive hierarchical clustering applied to median values. Climate summaries were derived from 800m, daily PRISM data spanning 1981-2010. # control color like this trellis.par.set(plot.line=list(col=&#39;RoyalBlue&#39;)) # control centers symbol and size here res &lt;- vizAnnualClimate(s$climate.annual, IQR.cex = 1.25, cex=1.1, pch=18) # plot figure, this is Lattice graphics print(res$fig) # do something with clustering par(mar=c(0,0,1,1)) # usually requires tinkering... plotProfileDendrogram(s$SPC, clust = res$clust, scaling.factor = 0.05, width = 0.2, y.offset = 1.3) mtext(&#39;sorted by annual climate summaries&#39;, side = 3, at = 0.5, adj = 0, line = -1.5, font=3) 1.4.2.2 Hillslope Position The vizHillslopePosition function (sharpshootR package) arranges hillslope position proportions (SSURGO) according to divisive hierarchical clustering. Proportions are used as characteristics for each soil series. The branches of the dendrogram are rotated so that ordering within the figure approximates the hydrologic gradient as closely as possible. Rotation is performed by the dendextend::rotate function. # result is a lattice graphics object res &lt;- vizHillslopePosition(s$hillpos) print(res$fig) 1.4.3 Pair-Wise Distances Between Subgroup-Level Taxa The following are demonstrations of pair-wise distances computed from categorical data and the use of a dendrogram to organize groups from Soil Taxonomy. Click here for details. # define a vector of series s.list &lt;- c(&#39;amador&#39;, &#39;redding&#39;, &#39;pentz&#39;, &#39;willows&#39;, &#39;pardee&#39;, &#39;yolo&#39;, &#39;hanford&#39;, &#39;cecil&#39;, &#39;sycamore&#39;, &#39;KLAMATH&#39;, &#39;MOGLIA&#39;, &#39;drummer&#39;, &#39;musick&#39;, &#39;zook&#39;, &#39;argonaut&#39;, &#39;PALAU&#39;) # get and SPC object with basic data on these series s &lt;- fetchOSD(s.list) # graphical check par(mar=c(0,0,2,0)) plot(s) ; title(&#39;Selected Pedons from Official Series Descriptions&#39;, line=0) # check structure of some site-level attributes # head(site(s))[, c(&#39;id&#39;, &#39;soilorder&#39;, &#39;suborder&#39;, &#39;greatgroup&#39;, &#39;subgroup&#39;)]) id soilorder suborder greatgroup subgroup AMADOR inceptisols xerepts haploxerepts typic haploxerepts ARGONAUT alfisols xeralfs haploxeralfs mollic haploxeralfs CECIL ultisols udults kanhapludults typic kanhapludults DRUMMER mollisols aquolls endoaquolls typic endoaquolls HANFORD entisols orthents xerorthents typic xerorthents KLAMATH mollisols aquolls cryaquolls cumulic cryaquolls par(mar=c(0,1,1,1)) # plot dendrogram + profiles d &lt;- SoilTaxonomyDendrogram(s, scaling.factor = 0.01, width=0.2, cex.names=0.5) Check the resulting distance matrix. print(d) 1.4.4 Soil Color Signatures See this related tutorial for additional examples. # manually convert Munsell -&gt; sRGB rgb.data &lt;- munsell2rgb(s$hue, s$value, s$chroma, return_triplets = TRUE) s$r &lt;- rgb.data$r s$g &lt;- rgb.data$g s$b &lt;- rgb.data$b # eval color signature pig &lt;- soilColorSignature(s, RescaleLightnessBy = 5, method=&#39;depthSlices&#39;) # display results as table kable_styling(knitr::kable(head(pig), digits = 3, row.names = FALSE)) id A.0.1 A.0.5 A.0.9 B.0.1 B.0.5 B.0.9 L.0.1 L.0.5 L.0.9 AMADOR 3.681 4.870 1.919 13.298 18.956 27.828 8.250 10.324 14.333 ARGONAUT 13.549 19.311 15.876 19.548 30.215 17.613 6.159 6.161 8.250 CECIL 7.378 32.895 28.722 25.999 29.497 35.807 8.254 8.251 8.254 DRUMMER 2.189 1.478 1.478 5.367 6.176 6.176 4.111 8.247 8.247 HANFORD 5.629 5.629 6.611 19.847 19.847 25.480 8.252 8.252 10.327 KLAMATH 2.189 2.189 10.371 5.367 5.367 37.715 4.111 4.111 8.257 # move row names over for distance matrix row.names(pig) &lt;- pig[, 1] d &lt;- daisy(pig[, -1]) dd &lt;- diana(d) # plot par(mar=c(0,0,0.25,1)) plotProfileDendrogram(s, dd, dend.y.scale = max(d) * 2, scaling.factor = 0.3, y.offset = 6, width=0.2, cex.names=0.5) 1.4.5 Clustering of Soil Colors Just for fun, use hierarchical clustering and nMDS on soil color data from the OSDs that were used in the previous example. # extract horizon data from select OSDs in above example h &lt;- horizons(s) # convert Munsell color notation to sRGB # these are moist colors rgb.data &lt;- munsell2rgb(h$hue, h$value, h$chroma, return_triplets = TRUE) lab.data &lt;- munsell2rgb(h$hue, h$value, h$chroma, returnLAB = TRUE) # check head(rgb.data) ## r g b ## 1 0.4360624 0.3706674 0.29697452 ## 2 0.5589675 0.4673350 0.35663875 ## 3 0.5589675 0.4673350 0.35663875 ## 4 0.7719679 0.6774631 0.48997537 ## 5 0.3940324 0.2499977 0.16682669 ## 6 0.4309729 0.2327690 0.09771028 head(lab.data) ## L A B ## 1 41.24855 3.681301 13.29762 ## 2 51.62124 4.870262 18.95563 ## 3 51.62124 4.870262 18.95563 ## 4 71.66388 1.919454 27.82850 ## 5 30.79580 13.548688 19.54789 ## 6 30.80674 19.311423 30.21539 # remove NA rgb.data &lt;- na.omit(rgb.data) lab.data &lt;- na.omit(lab.data) # retain unique colors rgb.data &lt;- unique(rgb.data) lab.data &lt;- unique(lab.data) # visualize colors in LAB coordinates pairs(lab.data, col=&#39;white&#39;, bg=rgb(rgb.data), pch=21, cex=2) # create distance matrix from LAB coordinates d &lt;- daisy(lab.data, stand=FALSE) # divisive heirarcical clustering d.hclust &lt;- as.hclust(diana(d)) # convert to phylo class for nicer plotting p &lt;- as.phylo(d.hclust) # perform nMDS on distance matrix d.sammon &lt;- sammon(d) # setup multi-figure page par(mfcol=c(1,2), mar=c(0,0,2,0), bg=grey(0.95)) # plot fan-style dendrogram plot(p, font=2, cex=0.5, type=&#39;fan&#39;, show.tip.label=FALSE, main=&#39;Dendrogram Representation&#39;) # add colors at dendrogram tips tiplabels(pch=21, cex=4, col=&#39;white&#39;, bg=rgb(rgb.data)) # plot nMDS ordination plot(d.sammon$points, type=&#39;n&#39;, axes=FALSE, xlab=&#39;&#39;, ylab=&#39;&#39;, asp=1, main=&#39;nMDS Ordination&#39;) abline(h=0, v=0, col=&#39;black&#39;, lty=3) points(d.sammon$points, bg=rgb(rgb.data), pch=21, cex=3.5, col=&#39;white&#39;) 1.4.6 How Do the Interpretations Compare? Example borrowed from this tutorial. library(reshape2) # set list of component names, same as soil color example s.list &lt;- c(&#39;amador&#39;, &#39;redding&#39;, &#39;pentz&#39;, &#39;willows&#39;, &#39;pardee&#39;, &#39;yolo&#39;, &#39;hanford&#39;, &#39;cecil&#39;, &#39;sycamore&#39;, &#39;KLAMATH&#39;, &#39;MOGLIA&#39;, &#39;drummer&#39;, &#39;musick&#39;, &#39;zook&#39;, &#39;argonaut&#39;, &#39;PALAU&#39;) # set list of relevant interpretations interp.list &lt;- c(&#39;ENG - Construction Materials; Topsoil&#39;, &#39;ENG - Sewage Lagoons&#39;, &#39;ENG - Septic Tank Absorption Fields&#39;, &#39;ENG - Unpaved Local Roads and Streets&#39;) # compose query q &lt;- paste0(&quot;SELECT UPPER(compname) as compname, mrulename, AVG(interplr) as interplr_mean FROM component INNER JOIN cointerp ON component.cokey = cointerp.cokey WHERE compname IN &quot;, format_SQL_in_statement(s.list), &quot; AND seqnum = 0 AND mrulename IN &quot;, format_SQL_in_statement(interp.list), &quot; AND interplr IS NOT NULL GROUP BY compname, mrulename;&quot;) # send query x &lt;- SDA_query(q) # reshape long -&gt; wide x.wide &lt;- dcast(x, compname ~ mrulename, value.var = &#39;interplr_mean&#39;) knitr::kable(x.wide, digits = 3, caption=&quot;Mean Fuzzy Ratings for Select Soil Series&quot;) Table 1.1: Mean Fuzzy Ratings for Select Soil Series compname ENG - Construction Materials; Topsoil ENG - Septic Tank Absorption Fields ENG - Sewage Lagoons ENG - Unpaved Local Roads and Streets AMADOR 0.000 1.000 1.000 0.691 ARGONAUT 0.050 1.000 1.000 1.000 CECIL 0.414 0.666 0.854 0.302 DRUMMER 0.000 1.000 1.000 1.000 HANFORD 0.678 0.989 1.000 0.220 KLAMATH 0.000 1.000 1.000 1.000 MOGLIA 0.000 1.000 0.500 1.000 MUSICK 0.245 1.000 0.963 0.832 PALAU 0.011 1.000 0.864 1.000 PARDEE 0.000 1.000 1.000 1.000 PENTZ 0.003 1.000 1.000 0.714 REDDING 0.022 1.000 1.000 0.907 SYCAMORE 0.824 0.998 0.756 0.919 WILLOWS 0.000 1.000 0.947 1.000 YOLO 0.843 0.914 0.608 0.769 ZOOK 0.004 1.000 1.000 1.000 # note: component name and series name have been converted to upper case # sort rows of fuzzy ratings based on profiles from OSDs new.order &lt;- match(x.wide$compname, profile_id(s)) x.wide &lt;- x.wide[new.order, ] # copy ids to row.names so that they are preserved in distance matrix row.names(x.wide) &lt;- x.wide$compname # create distance matrix d &lt;- daisy(x.wide[, -1]) # divisive hierarchical clustering clust &lt;- diana(d) par(mar=c(2,0,2,0)) plotProfileDendrogram(s, clust, dend.y.scale = 1.5, scaling.factor = 0.004, y.offset = 0.1, width=0.25, cex.names=0.45) title(&#39;Component Similarity via Select Fuzzy Ratings&#39;) mtext(&#39;Profile Sketches are from OSDs&#39;, 1) 1.4.7 MLRA Concepts via Climate and Elevation Samples Get and process example data, originally sampled from PRISM raster and DEM within MLRA 15, 18, 22A, and 22B. Variables include: elevation mean annual air temperature mean annuap precipitation fraction of annual precipitation as rain effective precipitation frost-free days growing degree days library(MASS) library(vegan) library(cluster) library(RColorBrewer) # get example data # init a temp file tf &lt;- tempfile() # download compressed CSV to temp file download.file(&#39;https://github.com/ncss-tech/stats_for_soil_survey/raw/master/data/clustering_and_ordination/MLRA-raster-data-example.csv.gz&#39;, destfile = tf, quiet = TRUE) # read-in from compressed CSV to data.frame object d.sub &lt;- read.csv(gzfile(tf), stringsAsFactors = FALSE) # check: note that the column names are quite strange head(d.sub) # set factor levels mu.set &lt;- c(&#39;15&#39;, &#39;18&#39;, &#39;22A&#39;, &#39;22B&#39;) d.sub$.id &lt;- factor(d.sub$.id, levels = mu.set) # define some nice colors cols &lt;- brewer.pal(9, &#39;Set1&#39;) # remove light colors cols &lt;- cols[c(1:5,7,9)] 1.4.7.1 Nonmetric Multidimensional Scaling A smooh surface fit to mean annual air temperature highlights structure within a nMDS ordination. m &lt;- metaMDS(d.sub[, -c(1:3)], distance = &#39;gower&#39;) # margins par(mar=c(1,1,3,1)) # setup plot o &lt;- ordiplot(m, type=&#39;n&#39;, axes=FALSE) # add points, colored accoring to MLRA points(o, &#39;sites&#39;, cex=1, col=cols[as.numeric(d.sub$.id)], pch=16) # overlay smooth surface of variable used in ordination ordisurf(m, d.sub$Mean.Annual.Air.Temperature..degrees.C., add=TRUE, col=&#39;black&#39;, labcex=1) legend(&#39;topleft&#39;, legend=mu.set, pch=16, col=cols, bty=&#39;n&#39;, cex=1.25) title(&#39;nMDS with mean annual air temperature (deg C) surface&#39;) box() 1.4.7.2 Principle Coordinates This example generates an ordination (via principal coordinates) of environmental variables (PRSIM and elevation) associated with MLRAs 15, 18, 22A, and 22B. Ellipses represent 50% probability contours via multivariate homogeneity of group dispersions. See comments in the code for details. Note that this example was extracted from the Region 2 Map Unit Comparison Report. Thoughts on interpretation: The relative position of points and ellipses are meaningful; absolute position will vary each time the figure is generated. Look for diffuse vs. concentrated clusters: these suggest relatively broadly vs. narrowly defined concepts. Nesting of clusters (e.g. smaller cluster contained by larger cluster) suggests super-set/subset relationships. Overlap is proportional to similarity. ## NOTE: data with very low variability will cause warnings # eval numerical distance, removing first 3 columns of IDs d.dist &lt;- daisy(d.sub[, -c(1:3)], stand=TRUE) ## map distance matrix to 2D space via principal coordinates d.betadisper &lt;- betadisper(d.dist, group=d.sub$.id, bias.adjust = TRUE, sqrt.dist = FALSE, type=&#39;median&#39;) ## fancy plot plot( d.betadisper, hull=FALSE, ellipse=TRUE, conf=0.5, col=cols, main=&#39;Ordination of Raster Samples\\n50% Probability Ellipse&#39;, sub=&#39;MLRA 15, 18, 22A, 22B&#39; ) Pair-wise comparisons at the 90% level of confidence. ## pair-wise comparisons of variance par(mar=c(4.5, 5.5, 4.5, 1)) plot(TukeyHSD(d.betadisper, conf.level = 0.9), las=1) This document is based on aqp version 1.27 and soilDB version 2.5.9 and sharpshootR version 1.7. "]]
